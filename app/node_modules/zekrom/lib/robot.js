"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _robotjs = require("robotjs");

var _robotjs2 = _interopRequireDefault(_robotjs);

var _ramda = require("ramda");

var _ramda2 = _interopRequireDefault(_ramda);

var _debug = require("debug");

var _debug2 = _interopRequireDefault(_debug);

var _robotKeys = require("./robotKeys");

var _robotKeys2 = _interopRequireDefault(_robotKeys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var log = (0, _debug2.default)("zekrom:Robot");

var Robot = function () {
  function Robot() {
    _classCallCheck(this, Robot);

    this.robot = _robotjs2.default;
    this.meta = {
      mouse: this.mouseMeta(),
      screen: this.screenMeta(),
      keyboard: this.keyboardMeta()
    };
    this.commandDelay = 5;
  }

  _createClass(Robot, [{
    key: "keyboardMeta",
    value: function keyboardMeta() {
      var keys = _robotKeys2.default.default;
      return keys;
    }
  }, {
    key: "setKeyboard",
    value: function setKeyboard(delay) {
      this.robot.setKeyboardDelay(delay);
    }
  }, {
    key: "executeKeyDown",
    value: function executeKeyDown(command, callback) {
      _robotjs2.default.keyToggle(command, "down");
      setTimeout(function () {
        callback();
      }, this.commandDelay);
    }
  }, {
    key: "executeKeyUp",
    value: function executeKeyUp(command, callback) {
      _robotjs2.default.keyToggle(command, "up");
      callback();
    }
  }, {
    key: "tap",
    value: function tap(key, modifier) {
      if (modifier) {
        if (Object.keys(_robotKeys2.default.default).includes(key) && Object.keys(_robotKeys2.default.modifier).includes(modifier)) {
          log("tap key: ", this.meta.keyboard[key], this.meta.keyboard[modifier]);
          this.robot.keyTap(this.meta.keyboard[key], this.meta.keyboard[modifier]);
        }
      } else {
        if (Object.keys(_robotKeys2.default.default).includes(key)) {
          log("tap key: ", this.meta.keyboard[key]);
          this.robot.keyTap(this.meta.keyboard[key]);
        } else {
          throw new Error("you need set correct key");
        }
      }
    }
  }, {
    key: "typing",
    value: function typing(input) {
      this.setKeyboard(100);
      var wait = input.split("\n");
      for (var index = 0; index < wait.length; index++) {
        this.robot.keyTap("enter");
        var element = wait[index];
        this.robot.typeString(element);
      }
    }
  }, {
    key: "mouseMeta",
    value: function mouseMeta() {
      var pos = this.robot.getMousePos();
      return pos;
    }
  }, {
    key: "screenMeta",
    value: function screenMeta() {
      var size = this.robot.getScreenSize();
      return size;
    }
  }, {
    key: "setMouse",
    value: function setMouse(delay) {
      this.robot.setMouseDelay(delay);
    }
  }, {
    key: "mouse",
    value: function mouse(point, action) {
      if (!_ramda2.default.has("x", point)) {
        switch (point) {
          case "current":
            point = this.mouseMeta();
            break;
          case "LeftTop":
            point = {
              x: 0,
              y: 0
            };
            break;
          case "LeftBottom":
            point = {
              x: 0,
              y: this.meta.screen.height
            };
            break;
          case "RightTop":
            point = {
              x: this.meta.screen.width,
              y: 0
            };
            break;
          case "RightBottom":
            point = {
              x: this.meta.screen.width,
              y: this.meta.screen.height
            };
            break;
          case "center":
            point = {
              x: this.meta.screen.width / 2,
              y: this.meta.screen.height / 2
            };
            break;
          default:
            throw new Error("you need set correct action point");
        }
      }
      switch (action) {
        case "smooth":
          this.robot.moveMouseSmooth(point.x, point.y);
          break;
        case "drag":
          this.robot.dragMouse(point.x, point.y);
          break;
        case "scroll":
          this.robot.scrollMouse(point.x, point.y);
          break;
        case "color":
          return this.robot.getPixelColor(point.x, point.y);
        default:
          this.robot.moveMouse(point.x, point.y);
      }
    }
  }, {
    key: "click",
    value: function click(point, keyMapping, isDouble, action) {
      this.mouse(point, action);
      this.robot.mouseClick(keyMapping, isDouble);
    }
  }, {
    key: "toggle",
    value: function toggle(point, keyMapping, timeOut, action) {
      var _this = this;

      this.mouse(point, action);
      this.robot.mouseToggle("down", keyMapping);
      setTimeout(function () {
        _this.robot.mouseToggle("up", keyMapping);
      }, timeOut);
    }
  }, {
    key: "drag",
    value: function drag(startPoint, endPoint, action) {
      this.mouse(startPoint, action);
      this.robot.mouseToggle("down");
      this.mouse(endPoint, "drag");
      this.robot.mouseToggle("up");
    }
  }, {
    key: "scroll",
    value: function scroll(point) {
      this.mouse(point, "scroll");
    }
  }]);

  return Robot;
}();

exports.default = Robot;
//# sourceMappingURL=robot.js.map